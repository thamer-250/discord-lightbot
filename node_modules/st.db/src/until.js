const fs = require("fs")
const path = require("path")
const Cryptr = require(require("path").resolve(__dirname, 'encrypt/index.js'));
const cryptrr = new Cryptr('myTotalySecretKey');
const { ApiOperator } = require('./requirements.js')

const stdb = {
  creationoptions: (options, defults) => {
    if (!options) return null;
    let configs = new Object();
    configs.debug = Boolean(options.debug);
    configs.path = options.path
    if (!configs.path) configs.path = defults.path
    return configs;
  },
  makeDB: (db, debug) => {
    if (debug) this.debug(`ST.db - Trying to read DB on this path [ ${db} ]`, "log");
    fs.access(db, fs.constants.F_OK, (err) => {
      if (err) {
        fs.writeFileSync(db, JSON.stringify({}, null, 4))
        if (debug) this.debug("ST.db - Database not found, creating one ...", "log");
      } else if (debug) this.debug("ST.db - Database found", "log");
    });
  }
}
class Data {
  constructor(dbName = String(), options = Object()) {
    this.BetaOnlineSupport = true
    let defaultDBname = "ST.db"
    this.dbName = dbName || "data"
    this.api = options.api || false
    this.log = options.log || false
    this.encrypt = options.encrypt || false
    this.options = stdb.creationoptions(options, {
      path: this.dbName
    })
    let basePath = process.cwd();
    if (this.dbName.startsWith(basePath)) {
      this.dbName = this.dbName.replace(basePath, "");
    }
    if (this.dbName.startsWith(`.${path.sep}`)) {
      this.dbName = this.dbName.slice(1);
    }
    if (!this.dbName.endsWith(".json")) {
      if (this.dbName.endsWith(path.sep)) {
        this.dbName += "stdb.json";
      } else {
        this.dbName += ".json";
      }
    }
    this.db = path.resolve(`./${this.dbName}`)
    stdb.makeDB(this.db, this.options.debug)
    if (this.log === true) {
      var color_console = [`1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`]
      var color_random = Math.floor(Math.random() * (color_console.length - 1) + 1)
      console.log(`\u001b[48;5;${color_console[color_random]}mST.db™\u001b[0m ▶ \u001b[38;5;${color_console[color_random]}mYour ${this.dbName}.st file has been successfully accessed\u001b[0m`)
      if (this.encrypt === true) {
        console.log(`➥ \u001b[38;5;${color_console[color_random]}mEncrypt: \u001b[0m${this.encrypt || 'false'}`)
      }
      console.log(`➥ \u001b[38;5;${color_console[color_random]}mLogs: \u001b[0m${this.log || 'false'}`)
    }
    if (this.api === true) {
      if (this.log === true) return console.log(`\u001b[0m➥ \u001b[38;5;${color_console[color_random]}mData API : \u001b[0m${this.api || 'false'}`);
      let data = this.load()
      ApiOperator(this.dbName, data)
    }
  }
  /**
   * @exemple db.set("st.db","test")
   * @param {*} data 
   * @param {*} value 
   * @returns 
   */
  set(key = String(), value) {
    if (!value) throw Error("ST.db - You must enter a value to write in the data");
    let data = this.load()
    data[key] = value
    if (typeof this.encrypt === 'boolean' && this.encrypt === false || !this.encrypt) {
      this.overwrite(data)
      if (this.log === true) return console.log(`\u001b[38;5;2m✚ \u001b[0m"${key}":"${value}" \u001b[38;5;2mhas been added in data\u001b[0m`);
    }
    if (this.encrypt === true) {
      if (typeof value == "boolean") return this.overwrite(data);
      // if (typeof value == "number") return this.overwrite(data);
      let encryptedString = cryptrr.encrypt(value);
      data[key] = encryptedString
      this.overwrite(data)
      if (this.log === true) return console.log(`\u001b[38;5;2m✚ \u001b[0m"${key}":"${encryptedString}" \u001b[38;5;2mhas been added in data\u001b[0m`);
    }
  }
  /**
   * @exemple db.encrypt("st.db")
   * @param data 
   * @returns 
   */
  encryptValue(value) {
    return cryptrr.encrypt(value);
  }
  /**
   * @exemple db.decrypt("389a474f48b7bf2c00")
   * @param data 
   * @returns 
   */
  decryptValue(value) {
    let vecrypt = cryptrr.decrypt(value);
    let numbertrue = Number(vecrypt)
    if (Number.isFinite(numbertrue) == false) {
      return vecrypt
    }
    return Number(numbertrue)
  }
  /**
   * @example db.get("st.db")
   * @param {*} key
   * @returns 
   */
  get(key = String()) {
    let data = this.load()
    let value = data[key]
    try {
      let vdecrypt = cryptrr.decrypt(value);
      let numbertrue = Number(vdecrypt)
      if (Number.isFinite(numbertrue) == false) {
        return vdecrypt
      }
      return Number(numbertrue)
    } catch (error) {
      return value
    }
  }
  /**
   * @example db.fetch("st.db")
   * @param {*} key
   * @returns 
   */
  fetch(key = String()) {
    return this.get(key)
  }
  /**
   * @example db.has(`st.db`)
   * @param  data 
   * @returns 
   */
  has(data) {
    if (!data) throw Error("ST.db - No data to has function");
    let fileData = this.load()
    if (!fileData[data]) return false;
    if (fileData[data]) return true;
  }
  /**
   * @example db.destroy()
   * @returns 
   */
  destroy() {
    let pathfile = this.options.path || "ST.db"
    try {
      fs.unlinkSync(`./${pathfile}/${this.dbName}.json`)
    } catch (err) {
      console.log(`\u001b[48;5;160mWarning!\u001b[0m\u001b[38;5;160m The data has been destroyed before!\u001b[0m`)
    }
    return;
  }
  /**
   * @example db.all()
   * @param limit
   * @returns 
   */
  all(limit = 0) {
    if (typeof limit !== "number") {
      throw new DatabaseError("Must be of limit number type!");
    }

    const arr = [];
    for (const key in this.load()) {
      arr.push({
        ID: key,
        data: this.load()[key]
      });
    }

    return limit > 0 ? arr.splice(0, limit) : arr;
  }
  /**
   * @example db.startsWith(`st.db`)
   * @param key
   * @returns 
   */
  startsWith(key) {
    return this.filter((element) => element.ID.startsWith(key));
  }
  /**
   * @example db.endsWith(`st.db`)
   * @param key
   * @returns 
   */
  endsWith(key) {
    return this.filter((element) => element.ID.endsWith(key));
  }
  /**
   * @example db.filter()
   * @param thisArg
   * @param callbackfn
   * @returns 
   */
  filter(callbackfn, thisArg) {
    if (thisArg) callbackfn = callbackfn.bind(thisArg);
    return this.all().filter(callbackfn);
  }
  /**
   * @example db.includes(`st.db`)
   * @param key
   * @returns 
   */
  includes(key) {
    return this.filter((element) => element.ID.includes(key));
  }
  /**
   * @example db.fetchAll()
   * @param key
   * @returns 
   */
  fetchAll() {
    return this.all()
  }

  /**
   * @example db.moveQuickDB(quickDB)
   * @param quickDB
   * @returns 
   */
  moveQuickDB(quickDB) {
    console.log("\u001b[38;5;2m\u001b[40;1mQuickDB to ST.db: Started copying database.\u001b[0m")
    quickDB.fetchAll().map((data) => {
      let deata = this.load()
      if (this.encrypt === true) {
        let encrypteddata = cryptrr.encrypt(data.data);
        deata[data.ID] = encrypteddata
        this.overwrite(deata)
        console.log(`\u001b[32m\u001b[40;1mCopied\u001b[0m ▶ \u001b[32;1m"${data.ID}"\u001b[0m:\u001b[32;1m${data.data}\u001b[0m`)
      }
      if (typeof this.encrypt === 'boolean' && this.encrypt === false || !this.encrypt) {
        deata[data.ID] = data.data
        this.overwrite(deata)
        console.log(`\u001b[32m\u001b[40;1mCopied\u001b[0m ▶ \u001b[32;1m"${data.ID}"\u001b[0m:\u001b[32;1m${data.data}\u001b[0m`)
      }
    })
    if (this.log === true) {
      var loading = "";
      for (var i = 0; i < 100; i++) {
        loading += `${(i + 1)}`;
        console.log(`\u001b[38;5;${(i + 15)}m${(i + 1)}%\u001b[0m`)
      }
    }
    console.log("\n\n\n\u001b[38;5;155mQuickDB to ST.db: \u001b[0mCopied successfully.\n")
  }
  /**
   * @example db.transferDB(fileDB)
   * @param fileDB
   * @returns 
   */
  transferDB(fileDB) {
    let filedata = fileDB.all()
    let olddata = this.load()
    fileDB.overwrite(olddata)
    fs.writeFileSync(this.db, JSON.stringify(filedata, null, 4))
    console.log("\u001b[38;5;116mST.db: \u001b[0mCopied successfully.")
  }
  /**
   * @example db.size(`kb`)
   * @param type
   * @returns 
   */
  size(type) {
    let pathfile = this.options.path || "ST.db"
    var stats = fs.statSync(`./${this.dbName}`)
    var fileSizeInBytes = stats.size;
    if (type === `KB` || type === `kb`) {
      var fileSizeInMegabytes = fileSizeInBytes / (1024);
      return fileSizeInMegabytes
    }
    if (type === `MB` || type === `mb`) {
      var fileSizeInMegabytes = fileSizeInBytes / (1024 * 1024);
      return fileSizeInMegabytes
    }
    return fileSizeInBytes
  }
  /**
   * @example db.remove(`st.db`)
   * @param key
   * @returns 
   */
  remove(key = String()) {
    let data = this.load()
    try {
      delete data[key]
    } catch (error) {
      error = null
    }
    this.overwrite(data)
  }
  /**
   * @example db.delete(`st.db`)
   * @param data
   * @returns 
   */
  delete(data = String()) {
    this.remove(data)
  }
  /**
   * @example db.deleteEach(`st.db`)
   * @param data
   * @returns 
   */
  deleteEach(data) {
    if (!data) throw Error("ST.db - No data to deleteEach")
    let fileData = this.load()
    let item = Object.keys(fileData)
    if (item === '') throw Error(nothingToDeleteeach)
    item = item.filter((Data) => Data.includes(data));
    item.forEach((Data) => {
      this.remove(Data)
    });
    return;
  }
  /**
   * @example db.load()
   * @returns 
   */
  load() {
    let data;
    try {
      data = JSON.parse(fs.readFileSync(this.db))
    } catch (error) {
      if (error) {
        data = JSON.parse("{}")
      }
    }

    return data;
  }
  /**
   * @example db.overwrite(`data`)
   * @param data
   * @returns 
   */
  overwrite(data) {
    fs.writeFileSync(this.db, JSON.stringify(data, null, 4))
  }
  /**
   * @example db.clear()
   * @returns 
   */
  clear() {
    let data = Object()
    this.overwrite(data)
  }
  /**
   * @example db.add(`data`,'=>')
   * @param data
   * @returns 
   */
  add(key = String(), value) {
    let Old = this.get(key)
    if (typeof Old == 'undefined' && Old == null) {
      this.set(key, value)
    }
    let dOld = this.get(key)
    try {
      Old.push(value)
    } catch (err) {
      if (err) {
        Old = dOld
        Old = Old + value
      }
    }
    this.set(key, Old)
  }
  /**
   * @example db.setDecrypt(`data`)
   * @param key
   * @param value
   * @returns 
   */
  setDecrypt(key = String(), value) {
    if (!value) throw Error("ST.db - You must enter a value to write in the data");
    let data = this.load()
    data[key] = value
    this.overwrite(data)
    if (this.log === true) return console.log(`\u001b[38;5;2m✚ \u001b[0m"${key}":"${value}" \u001b[38;5;2mhas been added in data\u001b[0m`);
  }
  /**
   * @example db.push(`st.db`,`data`)
   * @param key
   * @param value
   * @returns 
   */
  push(key, value) {
    if (!value) throw Error("ST.db - No value to push to the array")
    let data = this.get(key);
    if (!data) {
      return this.setDecrypt(key, [value]);
    }
    if (Array.isArray(data)) {
      data.push(value);
      return this.setDecrypt(key, data);
    } else {
      return this.setDecrypt(key, [value]);
    }
  }
  /**
   * @example db.unpush(`st.db`,`data`)
   * @param db
   * @param data
   * @returns 
   */
  unpush(db, data) {
    if (!db) throw Error("ST.db - No array fetch")
    if (!data) throw Error("ST.db - There is no data to execute on it")
    var arr = [];
    if (this.get(db)) {
      arr = this.get(db);
    }
    arr = arr.filter((x) => x !== data);
    this.setDecrypt(db, arr);
  }
  /**
   * @example db.type(`st.db`)
   * @param key
   * @returns 
   */
  type(key) {
    const data = this.get(key);
    if (Array.isArray(data) || data instanceof Array) return "array";
    else return typeof data;
  }
  /**
   * @example db.math(`st.db`,`+`,1)
   * @param key
   * @param operator
   * @param value
   * @param goToNegative
   * @returns 
   */
  math(key, operator, value, goToNegative = false) {
    if (typeof value !== "number") throw Error(`ST.db - The type of value is not a number.`);
    if (value <= 0) throw Error(`ST.db - Value cannot be less than 1`);
    value = Number(value);
    if (typeof goToNegative !== "boolean") throw Error(`ST.db - The goToNegative parameter must be of boolean type.`);
    let data = this.get(key);
    if (data <= 0) throw Error(`ST.db - Value cannot be less than 1`);
    if (!data) {
      return this.set(key, value);
    }
    if (typeof data !== "number") throw Error(`ST.db - ${key} ID data is not a number type data.`);
    data = Number(data);
    switch (operator) {
      case "+":
        data += value;
        return this.set(key, data);
        break;
      case "-":
        data -= value;
        if (goToNegative === false && data < 1) data = 0;
        return this.set(key, data);
        break;
      case "*":
        data *= value;
        return this.set(key, data);
        break;
      case "/":
        data /= value;
        return this.set(key, data);
        break;
      case "%":
        data %= value;
        return this.set(key, data);
        break;
      default:
        return undefined;
        break;
    }
  }
  /**
   * @example db.arrayFetch('st.db',1)
   * @param array
   * @param number
   * @returns 
   */
  arrayFetch(array, number) {
    let fileData = this.load()
    if (!array) throw Error("ST.db - No array to array fetch")
    if (!number && number != 0) throw Error("ST.db - No   index/number to array fetch")
    if (!fileData[array] && !Array.isArray(fileData[array])) throw Error("ST.db - The array to fetch dosen't exist or it's not array")
    if (typeof number !== "number" && value !== 0) throw Error(`ST.db - The number/index to array fetch must be a number, received type: ${typeof value}`);
    if (!fileData[array][number]) fileData[array][number] = null
    return fileData[array][number];
  }
  /**
   * @example db.objectFetch('st.db',`data`)
   * @param object
   * @param key
   * @returns 
   */
  objectFetch(object, key) {
    let fileData = this.load()
    if (!object) throw Error("ST.db - No object to object fetch")
    if (!key) throw Error("ST.db - No key to object fetch")
    if (!fileData[object]) throw Error("ST.db - The object to object fetch dosen't exist in the database");
    if (typeof fileData[object] !== 'object') throw Error("ST.db - The provided object to object fetch is not an object in the database");
    if (!fileData[object][key]) fileData[object][key] = null
    return fileData[object][key]
  }
}


// Copyright 2021, ST.db
module.exports = Data